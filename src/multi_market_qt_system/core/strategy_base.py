from abc import ABC, abstractmethod
from typing import Any, Dict, List, Literal
import logging

logger = logging.getLogger(__name__)


class StrategyBase(ABC):
    """
    策略基类，定义策略生命周期与核心接口。
    支持 on_bar (增量) 与 batch_run (批量回测) 两种模式。
    """

    def __init__(self, name: str) -> None:
        self.name = name
        self.signals: List[Dict[str, Any]] = []
        logger.info("Initialized strategy: %s", name)

    @abstractmethod
    def generate(self, bar: Dict[str, Any]) -> None:
        """
        收到单个 bar 时生成 signal 并通过 emit_signal 缓存。
        :param bar: 单根行情数据
        """
        ...

    def on_bar(self, bar: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        增量模式：逐根 bar 推进策略。
        :return: 本根 bar 产生的所有信号列表
        """
        logger.debug("on_bar called for %s with bar: %s", self.name, bar)

        # 清除上次未取信号
        self.signals.clear()
        # 调用子类实现
        self.generate(bar)
        # 返回并清空缓存
        sigs = self.signals.copy()
        self.signals.clear()

        logger.debug("Signals generated by %s: %s", self.name, sigs)
        return sigs

    def batch_run(self, bars: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        批量回测模式：一次性传入所有 bars，按顺序生成信号。
        :return: 全量信号列表（带时间戳排序）
        """
        logger.info("batch_run started for %s with %d bars", self.name, len(bars))

        all_sigs = []
        for bar in bars:
            self.signals.clear()
            self.generate(bar)
            all_sigs.extend(self.signals)
        logger.info("batch_run completed for %s, total signals: %d", self.name, len(all_sigs))
        # 按 timestamp 排序
        return sorted(all_sigs, key=lambda x: x['timestamp'])

    def emit_signal(self,
                    timestamp: Any,
                    symbol: str,
                    action: Literal['BUY', 'SELL', 'SHORT', 'COVER'],
                    price: float,
                    quantity: int) -> None:
        """
        缓存交易信号
        """
        signal = {
            'timestamp': timestamp,
            'symbol': symbol,
            'action': action,
            'price': price,
            'quantity': quantity
        }
        logger.debug("Strategy %s emit signal: %s", self.name, signal)
        self.signals.append(signal)
